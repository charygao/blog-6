---
layout:     post
title:      手机辅助功能实现抢微信红包
subtitle:   辅助功能服务AccessibilityService
date:       2020-01-21
author:     JovenHe
header-img: img/post-bg-hook.jpg
catalog: true
tags:
    - 分析
    


---

19年下半年就没怎么写过文章了，因为9月份换了工作，开始做政企手机管控相关的工作，有太多需要学习的东西，自己本身就是个菜鸟，所以一直没时间写

最近都是开年会的开年会，聚餐的聚餐，相信大家都没少抢红包，我也利用最近所学做了一个小功能来抢红包，用的就是 辅助功能服务AccessibilityService，这个东西就算是纯粹的Android开发者也很少用，功能就相当于Xposed，但它是Android自带的服务，目的在于帮助那些具有视觉、身体或年龄相关限制的用户更轻松的使用Android设备和应用，它一般提供了页面元素查找功能和元素点击功能。在我工作项目中就用于自动始终允许权限、自动允许使用情况访问权、自动允许显示在其他应用上层等权限

下面我们就开始通过AccessibilityService来做一个抢红包的APP

### 声明服务

新建一个Service，继承自 AccessibilityService，主要逻辑都是在onAccessibilityEvent方法中进行，代表界面发生某些事件就会触发该方法，例如点击、长按、触摸、焦点、滑动等等事件

```java
public class HandleAccessService extends AccessibilityService {

    private static final String TAG = "HandleAccessService";

    private Context mContext;

    @Override
    public void onCreate() {
        super.onCreate();
        mContext = this.getApplicationContext();
    }
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {

    }
    @Override
    public void onInterrupt() {

    }

}
```

在清单文件中注册，

```xml
		<service
            android:name=".service.HandleAccessService"
            android:label="@string/accessibility_control_service_label"
            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE">
            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/accessibility_service_config" />

            <intent-filter>
                <action android:name="android.accessibilityservice.AccessibilityService" />
            </intent-filter>
        </service>
```

label是服务名，permission代表需要辅助功能服务，meta-data中的resource指服务说明



### 主要方法

以下列举的只是我刚接触到的常用方法，还是有很多很重要的方法的，可以查官方文档进行学习

getRootInActiveWindow

*获取窗体中的节点信息*，会获取到当前窗体的所有view节点

findAccessibilityNodeInfosByViewId

*通过ViewID找到节点信息*

findAccessibilityNodeInfosByText

*通过文本找到节点信息*

getParent()

*获取该节点的父节点*

performAction

*对该节点执行对应操作*，例如点击、获取焦点、设置文本

### 分析

辅助服务来抢红包就是对界面元素分析后，针对未抢的红包节点View进行模拟点击，以此来实现

用于开发辅助的重要工具就是Android Device Monitor，可以在AndroidSDK->tools->monitor.bat打开

可以看到是可以进行view树的分析的，可以查看选中view的详细信息、节点树的嵌套信息

![](C:\Users\huangzhencheng\Documents\TIM图片20200121113318.png)

##### 点击红包消息

可以看到红包消息与其他消息的不同点是红包消息的底部有一个“微信红包”，可以以此来找到红包节点，而且未领取的红包上的文本是“领取红包”，可以以此避免重复点击红包

```
		AccessibilityNodeInfo mRootNode = getRootInActiveWindow();
        if (mRootNode != null) {
            
        
            List<AccessibilityNodeInfo> luckyMoneyNode = mRootNode.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/afp");
            if (luckyMoneyNode != null && !luckyMoneyNode.isEmpty()) {
                for (AccessibilityNodeInfo accessibilityNodeInfo : luckyMoneyNode) {
                    if (accessibilityNodeInfo.getText().toString().equals("微信红包")) {
                        List<AccessibilityNodeInfo> getNode = accessibilityNodeInfo.getParent().getParent().findAccessibilityNodeInfosByText("领取红包");
                        if (getNode != null && !getNode.isEmpty()) {
                            accessibilityNodeInfo.getParent().getParent().performAction(AccessibilityNodeInfo.ACTION_CLICK);
                            break;
                        }
                    }
                }
            }
            mRootNode.recycle();
        }
```

##### 打开红包

![](C:\Users\huangzhencheng\Documents\TIM图片20200121114923.png)

这一步直接点击就行，找到开的按钮进行点击

```java
List<AccessibilityNodeInfo> childNodes = mRootNode.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/c85");
            if (childNodes != null && childNodes.size() != 0) {
                childNodes.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);
            }
```



红包详情页返回



```java
List<AccessibilityNodeInfo> toolbarTextNodes = mRootNode.findAccessibilityNodeInfosByViewId("android:id/text1");if (toolbarTextNodes != null && toolbarTextNodes.size() != 0) {    if (toolbarTextNodes.get(0).equals("红包详情")) {        toolbarTextNodes.get(0).getParent().getParent().findAccessibilityNodeInfosByViewId("com.tencent.mm:id/ht").get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);    }}
```

### 使用

这个app使用是要配合Xposed框架来使用的，所以说Xposed真的是一个神器。Xposed中FDex2模块勾选上。

打开app后选中你要脱壳的app，然后打开要脱壳的app，就可以在/data/user/0/包名 下看到多出来的dex文件，这就是脱出来的。

### 原理

先jadx-gui反编译一下这个app吧
<a href="https://sm.ms/image/oMZWfzG8sKEjq6m" target="_blank"><img src="https://i.loli.net/2019/09/23/oMZWfzG8sKEjq6m.png" /></a>

可以很容易找到Xposed入口是MainHook这个类

直接看类中的handleLoadPackage方法

<a href="https://sm.ms/image/feFtyG7S4o85xNQ" target="_blank"><img src="https://i.loli.net/2019/09/23/feFtyG7S4o85xNQ.png" ></a>

可以看到会先用XSharedPreferences获取指定app的包名，可以看出打开 app是MainActivity，并且点击要脱壳的app时会用SharedPreferences保存包名，留着在此时做对比。

继续向下看其实主要拦截的是系统ClassLoader类的loadClass方法，那么拦截到后要做什么

<a href="https://sm.ms/image/uq6IiFVaMvkKtHb" target="_blank"><img src="https://i.loli.net/2019/09/23/uq6IiFVaMvkKtHb.png" ></a>

可以看到它是通过反射调用Dex类的getBytes得到dex对象的byte数组对象，然后写入到File文件就得到了dex文件

### 总结

FDex2的原理还是很简单的，针对加壳app它总会调用loadClass来加载真正执行的class，然后利用反射得到Dex的byte数组数据，然后生成文件就可以了。